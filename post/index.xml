<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rsquared Academy Blog</title>
    <link>/post/index.xml</link>
    <description>Recent content in Posts on Rsquared Academy Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2014-2017. All rights reserved.</copyright>
    <lastBuildDate>Wed, 17 May 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>forcats: Working with factor data in R</title>
      <link>/post/forcats-working-with-factor-data-in-r/</link>
      <pubDate>Wed, 17 May 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/forcats-working-with-factor-data-in-r/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
    <item>
      <title>Why you should know the Normal distribution?</title>
      <link>/post/why-you-should-know-the-normal-distribution/</link>
      <pubDate>Fri, 12 May 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/why-you-should-know-the-normal-distribution/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
    <item>
      <title>Introduction to tibbles</title>
      <link>/post/introduction-to-tibbles/</link>
      <pubDate>Sat, 22 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/introduction-to-tibbles/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;tibbles are a modern version of data frames that retain the good aspects (of data frames) while getting rid of the frustrating and annoying parts. tibbles are part of the &lt;a href=&#34;http://tidyverse.org/&#34;&gt;tidyverse&lt;/a&gt;. In this post, we will learn how tibbles makes certain parts of the data analysis workflow easier by being different from data frames. Specifically, we will learn&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;how to create tibbles&lt;/li&gt;
&lt;li&gt;how to convert other objects to tibbles&lt;/li&gt;
&lt;li&gt;compare tibbles with data frames&lt;/li&gt;
&lt;li&gt;to manipulate tibbles&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;creating-tibbles&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Creating tibbles&lt;/h3&gt;
&lt;p&gt;In this first section, we will create tibbles using the &lt;code&gt;tibble()&lt;/code&gt; function and compare them to data frames.&lt;/p&gt;
&lt;div id=&#34;tibble-never-changes-inputs-type&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;tibble never changes input’s type&lt;/h4&gt;
&lt;p&gt;In the &lt;code&gt;data.frame()&lt;/code&gt; function, any column with &lt;code&gt;character&lt;/code&gt; data is converted to &lt;code&gt;factors&lt;/code&gt; unless you set &lt;code&gt;stringsAsFactors&lt;/code&gt; argument to &lt;code&gt;FALSE&lt;/code&gt;. tibble takes care of this by never changing any input’s type. As you can observe in the below example, tibbles do not convert &lt;code&gt;characters&lt;/code&gt; to &lt;code&gt;factors&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble(x = letters,
       y = 1:26,
       z = sample(100, 26))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 26 × 3
##        x     y     z
##    &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
## 1      a     1    60
## 2      b     2     3
## 3      c     3     8
## 4      d     4    47
## 5      e     5    28
## 6      f     6    96
## 7      g     7    30
## 8      h     8     6
## 9      i     9    84
## 10     j    10    24
## # ... with 16 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tibble-never-adjusts-variable-names&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;tibble never adjusts variable names&lt;/h4&gt;
&lt;p&gt;If there is more than one word in a variable name, &lt;code&gt;data.frame()&lt;/code&gt; will add a &lt;code&gt;.&lt;/code&gt; and join them but tibble never adjusts variable names. Below is an example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(data.frame(`order value` = 10))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;order.value&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(tibble(`order value` = 10))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;order value&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tibble-never-prints-all-the-rows&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;tibble never prints all the rows&lt;/h4&gt;
&lt;p&gt;tibble only shows the first ten rows and all the columns that fit on one screen. Below the column names, it prints the column type as well. Let us look at an example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- 1:100
y &amp;lt;- letters[1]
z &amp;lt;- sample(c(TRUE, FALSE), 100, replace = TRUE)
tibble(x, y, z)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 100 × 3
##        x     y     z
##    &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt;
## 1      1     a  TRUE
## 2      2     a FALSE
## 3      3     a  TRUE
## 4      4     a FALSE
## 5      5     a FALSE
## 6      6     a  TRUE
## 7      7     a FALSE
## 8      8     a FALSE
## 9      9     a FALSE
## 10    10     a FALSE
## # ... with 90 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tibble-never-recycles-vectors-of-length-greater-than-1&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;tibble never recycles vectors of length greater than 1&lt;/h4&gt;
&lt;p&gt;tibble will never recycle a vector of length greater than 1. If you observe the previous example, we could have used all the letters instead of just the first letter but tibble will return an error if the vectors are of length greater than 1.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;creating-tibbles-ii&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Creating tibbles II&lt;/h3&gt;
&lt;p&gt;In the previous section, we created tibbles using the &lt;code&gt;tibble()&lt;/code&gt; function by directly inputting data as arguments. In this section, we will convert the following objects to tibble using the &lt;code&gt;as_tibble()&lt;/code&gt; function:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data.frame&lt;/li&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;li&gt;matrix&lt;/li&gt;
&lt;li&gt;table&lt;/li&gt;
&lt;li&gt;tbl_df&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;dataframes&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;DataFrames&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as_tibble(iris)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 150 × 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;  &amp;lt;fctr&amp;gt;
## 1           5.1         3.5          1.4         0.2  setosa
## 2           4.9         3.0          1.4         0.2  setosa
## 3           4.7         3.2          1.3         0.2  setosa
## 4           4.6         3.1          1.5         0.2  setosa
## 5           5.0         3.6          1.4         0.2  setosa
## 6           5.4         3.9          1.7         0.4  setosa
## 7           4.6         3.4          1.4         0.3  setosa
## 8           5.0         3.4          1.5         0.2  setosa
## 9           4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa
## # ... with 140 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;lists&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Lists&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;l &amp;lt;- list(x = 1:32, y = sample(100, 32), z = replicate(32, letters, simplify = FALSE))
as_tibble(l)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 32 × 3
##        x     y          z
##    &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;     &amp;lt;list&amp;gt;
## 1      1    50 &amp;lt;chr [26]&amp;gt;
## 2      2    47 &amp;lt;chr [26]&amp;gt;
## 3      3    81 &amp;lt;chr [26]&amp;gt;
## 4      4    20 &amp;lt;chr [26]&amp;gt;
## 5      5    75 &amp;lt;chr [26]&amp;gt;
## 6      6     5 &amp;lt;chr [26]&amp;gt;
## 7      7    34 &amp;lt;chr [26]&amp;gt;
## 8      8    86 &amp;lt;chr [26]&amp;gt;
## 9      9     4 &amp;lt;chr [26]&amp;gt;
## 10    10    80 &amp;lt;chr [26]&amp;gt;
## # ... with 22 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;matrix&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Matrix&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;m &amp;lt;- matrix(sample(1000, 2600, replace = TRUE), ncol = 26)
colnames(m) &amp;lt;- letters
as_tibble(m)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 100 × 26
##        a     b     c     d     e     f     g     h     i     j     k     l
##    &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
## 1    923   644   613    33   884   254    26   805   954    64   162   837
## 2    734   105   631   345   180   937   923   197   750    41   434   232
## 3    376   603    36    91   554   673   452   161   861   874   193   329
## 4    801   191   855   694   741   160   885   913   247   856   882   861
## 5    193   381   133     8   537   570    40   812    98   251   680    14
## 6     85   155   327    29   502   429   942   658   297   159   620   374
## 7    610   290    21   293    62   733   397   284   786    84   162   117
## 8    335   912    67   337   207   450   352   856   637   757   512    29
## 9    823   920   548   725   579   917   867   683   697   152    31   631
## 10   493   146   293   808   489   191   599   155   359   735    11   533
## # ... with 90 more rows, and 14 more variables: m &amp;lt;int&amp;gt;, n &amp;lt;int&amp;gt;, o &amp;lt;int&amp;gt;,
## #   p &amp;lt;int&amp;gt;, q &amp;lt;int&amp;gt;, r &amp;lt;int&amp;gt;, s &amp;lt;int&amp;gt;, t &amp;lt;int&amp;gt;, u &amp;lt;int&amp;gt;, v &amp;lt;int&amp;gt;,
## #   w &amp;lt;int&amp;gt;, x &amp;lt;int&amp;gt;, y &amp;lt;int&amp;gt;, z &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;table&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Table&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;k &amp;lt;- table(mtcars$cyl)
as_tibble(k)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 × 2
##    Var1     n
##   &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;
## 1     4    11
## 2     6     7
## 3     8    14&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tbl_df&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;tbl_df&lt;/h4&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;k &amp;lt;- tbl_df(iris)
as_tibble(k)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 150 × 5
##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
##           &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;  &amp;lt;fctr&amp;gt;
## 1           5.1         3.5          1.4         0.2  setosa
## 2           4.9         3.0          1.4         0.2  setosa
## 3           4.7         3.2          1.3         0.2  setosa
## 4           4.6         3.1          1.5         0.2  setosa
## 5           5.0         3.6          1.4         0.2  setosa
## 6           5.4         3.9          1.7         0.4  setosa
## 7           4.6         3.4          1.4         0.3  setosa
## 8           5.0         3.4          1.5         0.2  setosa
## 9           4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa
## # ... with 140 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can test if an object is a tibble using the &lt;code&gt;is_tibble()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is_tibble(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is_tibble(as_tibble(mtcars))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tribble&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Tribble&lt;/h4&gt;
&lt;p&gt;Another way to create tibbles is using the &lt;code&gt;tribble()&lt;/code&gt; function. tribble is short for transposed tibbles. It is customized for data entry in code. Column names start with &lt;code&gt;~&lt;/code&gt; and values are separated by commas. Below is an example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tribble(
  ~x, ~y, ~z,
  #--|--|----
  1, TRUE, &amp;#39;a&amp;#39;,
  2, FALSE, &amp;#39;b&amp;#39;
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 × 3
##       x     y     z
##   &amp;lt;dbl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;
## 1     1  TRUE     a
## 2     2 FALSE     b&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;column-names&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Column Names&lt;/h4&gt;
&lt;p&gt;Names of the columns in tibbles need not be valid R variable names. They can contain unusual characters like a space or a smiley but must be enclosed in ticks. Below is an example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble(
  ` ` = &amp;#39;space&amp;#39;,
  `2` = &amp;#39;integer&amp;#39;,
  `:)` = &amp;#39;smiley&amp;#39;
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 × 3
##     ` `     `2`   `:)`
##   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;
## 1 space integer smiley&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;section&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with tidyverse</title>
      <link>/post/getting-started-with-tidyverse/</link>
      <pubDate>Thu, 06 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/getting-started-with-tidyverse/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;p&gt;This is the first post in the series &lt;strong&gt;Data Wrangling with R&lt;/strong&gt;. In this series, we will look at the challenges faced when working with data of different types coming from different sources and explore tools available in R to overcome such challenges.&lt;/p&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&#34;http://tidyverse.org/&#34;&gt;tidyverse&lt;/a&gt; is a collection of R packages that share a common underlying philosophy and are designed to work together. They share common data representations and API design.&lt;/p&gt;
&lt;p&gt;The core packages of tidyverse are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ggplot2.tidyverse.org/&#34;&gt;ggplot2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dplyr.tidyverse.org/&#34;&gt;dplyr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tidyr.tidyverse.org/&#34;&gt;tidyr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://readr.tidyverse.org/&#34;&gt;readr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://purrr.tidyverse.org/&#34;&gt;purrr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tibble.tidyverse.org/&#34;&gt;tibble&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Packages available for working with specific data types include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tidyverse/hms&#34;&gt;hms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stringr.tidyverse.org/&#34;&gt;stringr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lubridate.tidyverse.org/&#34;&gt;lubridate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://forcats.tidyverse.org/&#34;&gt;forcats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following packages make it easy to import data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wesm/feather&#34;&gt;feather&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://haven.tidyverse.org/&#34;&gt;haven&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://readxl.tidyverse.org/&#34;&gt;readxl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jeroen/jsonlite&#34;&gt;jsonlite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/r-lib/xml2&#34;&gt;xml2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/r-lib/httr&#34;&gt;httr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hadley/rvest&#34;&gt;rvest&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will explore most of the above packages (except purrr, httr, rvest) using case studies and understand how using the tidyverse will streamline data analysis workflow by reducing the time spent on reshaping/restructuring data for different types of analysis. In the next post, we will learn about &lt;a href=&#34;http://tibble.tidyverse.org/&#34;&gt;tibbles&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Working with strings in R using stringr</title>
      <link>/post/working-with-strings-in-r-using-stringr/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/working-with-strings-in-r-using-stringr/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;p&gt;Functions&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_count&lt;/code&gt;: count number of matches in string In cart, search for products with units &amp;gt; 1&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_detect&lt;/code&gt;: detect if a pattern is present in string In cart, check if certain product has been purchased.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_match&lt;/code&gt;: use for landing pages&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_locate&lt;/code&gt;: locate special character to truncate&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_replace&lt;/code&gt;: replace set of products with category&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_split&lt;/code&gt;: split url&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_subset&lt;/code&gt;: subset url&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_trim&lt;/code&gt;: remove white space from url&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_len&lt;/code&gt;: length of string; test input&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_trun&lt;/code&gt;: truncate url&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;str_sub&lt;/code&gt;: extract and replace substrings&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>How to work with dates in R</title>
      <link>/post/how-to-work-with-dates-in-r/</link>
      <pubDate>Thu, 09 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/how-to-work-with-dates-in-r/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This is the 5th post in the series &lt;strong&gt;Data Wrangling with R&lt;/strong&gt;. In the previous &lt;a href=&#34;https://rsquaredacademy.github.io/post/data-manipulation-in-r-with-dplyr/&#34;&gt;post&lt;/a&gt;, we learnt to manipulate dataframes using the &lt;a href=&#34;https://CRAN.R-project.org/package=dplyr&#34;&gt;dplyr&lt;/a&gt; package. In this post, we will learn to work with date/time data in R using &lt;a href=&#34;https://CRAN.R-project.org/package=lubridate&#34;&gt;lubridate&lt;/a&gt;, an R package that makes it easy to work with dates and time. Let us begin by installing and loading the lubridate pacakge.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: methods&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;lubridate&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:base&amp;#39;:
## 
##     date&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;quick-overview&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Quick Overview&lt;/h3&gt;
&lt;p&gt;Use &lt;code&gt;origin&lt;/code&gt; to get the origin for the &lt;code&gt;Date&lt;/code&gt; and other date/time objects in R.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lubridate::origin&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1970-01-01 UTC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are functions to check current date, time, timezone and AM/PM. Let us take a quick look at these:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;now()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2017-06-15 13:23:43 IST&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;today()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;2017-06-15&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;am(now())  &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pm(now())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to explore all the functionality provided by the lubridate package, we will look at a simple scenario. Let us say you are going on a vacation to Atlanta. You plan to reach there on 10th April 2017 and end your vacation on 18th April 2017. Let us save these dates as &lt;em&gt;arrival&lt;/em&gt; and &lt;em&gt;departure&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;add-hour-minute-and-seconds&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;add hour, minute and seconds&lt;/h1&gt;
&lt;p&gt;arrived &amp;lt;- ymd_hms(‘2017-04-13 12:00:00’) departure &amp;lt;- ymd_hms(‘2017-05-07 12:00:00’)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;specify-timezone&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;specify timezone&lt;/h1&gt;
&lt;p&gt;arrived &amp;lt;- ymd_hms(‘2017-05-08 20:34:18’, tz = ‘UTC’) arrived&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;duration&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;duration&lt;/h1&gt;
&lt;p&gt;dur &amp;lt;- duration(hours = 10, minutes = 6) as.numeric(dur, “hours”) as.numeric(dur, “minutes”)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;day-light-savings-time&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;day light savings time&lt;/h1&gt;
&lt;p&gt;dst(arrived)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;number-of-days-in-a-month&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;number of days in a month&lt;/h1&gt;
&lt;p&gt;days_in_month(10)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;parse-dates-and-times&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;parse dates and times&lt;/h1&gt;
&lt;p&gt;ymd(20170508) mdy(‘05-08-2017’) dmy(‘08/05/2017’)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;set-and-extract-information-from-timezone&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;set and extract information from timezone&lt;/h1&gt;
&lt;p&gt;date(arrived) second(arrived) minute(arrived) hour(arrived) day(arrived) wday(arrived) yday(arrived) week(arrived) month(arrived) year(arrived)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;time-intervals&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;time intervals&lt;/h1&gt;
&lt;p&gt;stay &amp;lt;- interval(arrived, departure) stay&lt;/p&gt;
&lt;p&gt;outing &amp;lt;- interval(ymd(20170420), ymd(20170428)) outing&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;do-stay-and-outing-overlap&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;do stay and outing overlap&lt;/h1&gt;
&lt;p&gt;int_overlaps(stay, outing) setdiff(outing, stay)&lt;/p&gt;
&lt;p&gt;int_start(stay) int_end(stay) int_flip(stay) int_shift(stay, by = duration(days = 2)) int_shift(stay, by = duration(hours = 2))&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;arithmetic-with-datetimes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;arithmetic with date/times&lt;/h1&gt;
&lt;p&gt;minutes(2) dminutes(2)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;check-if-a-year-is-leap-year&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;check if a year is leap year&lt;/h1&gt;
&lt;p&gt;leap_year(2017)&lt;/p&gt;
&lt;p&gt;ymd(20160131) + years(1) ymd(20160131) + dyears(1) # adds 365 days&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;meeting&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;meeting&lt;/h1&gt;
&lt;p&gt;meeting &amp;lt;- ymd_hms(“2016-07-01 09:00:00”) meetings &amp;lt;- meeting + week(0:5)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;convert-stay-to-days-hours-seconds&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;convert stay to days, hours, seconds&lt;/h1&gt;
&lt;p&gt;stay / ddays(1) stay / ddays(2) stay / dhours() stay / dminutes() stay / dseconds() time_length(stay) stay %% months(1)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;convert-seconds-to-minutes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;convert seconds to minutes&lt;/h1&gt;
&lt;p&gt;make_difftime(112, units = ‘minutes’) make_difftime(112, units = ‘hour’)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-long-was-my-stay&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;how long was my stay&lt;/h1&gt;
&lt;p&gt;as.period(stay %% months(1)) as.period(stay)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;use-lubridate-inside-functions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;1. use lubridate inside functions&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;make_difftimedays-31&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;2. make_difftime(days = 31)&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;period&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;3. period&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;quarter&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;4. quarter&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;semester&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;5. semester&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;rollback&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;6. rollback&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;round-date-floor-date-ceiling-date&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;7. round date, floor date, ceiling date&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;link-to-lubridate-page-on-cran&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;link to lubridate page on CRAN&lt;/h1&gt;
&lt;/div&gt;
&lt;div id=&#34;link-to-lubridate-paper&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;link to lubridate paper&lt;/h1&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Data Manipulation in R with dplyr</title>
      <link>/post/data-manipulation-in-r-with-dplyr/</link>
      <pubDate>Sat, 18 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/data-manipulation-in-r-with-dplyr/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;According to a &lt;a href=&#34;http://visit.crowdflower.com/rs/416-ZBE-142/images/CrowdFlower_DataScienceReport_2016.pdf&#34;&gt;survey&lt;/a&gt; by &lt;a href=&#34;https://www.crowdflower.com/&#34;&gt;CrowdFlower&lt;/a&gt;, data scientists spend most of their time cleaning and manipulating data rather than mining or modeling them for insights. As such, it becomes important to have tools that make data manipulation faster and easier. In today’s post, we introduce you to &lt;a href=&#34;http://dplyr.tidyverse.org/&#34;&gt;dplyr&lt;/a&gt;, a grammar of data manipulation.&lt;/p&gt;
&lt;div id=&#34;why-dplyr&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Why dplyr?&lt;/h4&gt;
&lt;p&gt;dplyr helps us solve the most common data manipulation challenges such as filtering rows, selecting columns, sorting data, creating new columns, summarizing data etc. In order to truly appreciate dplyr, we will compare it to the functions in base R.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;installation&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Installation&lt;/h4&gt;
&lt;p&gt;You can install a stable version of &lt;code&gt;dplyr&lt;/code&gt; from CRAN or the latest development version from GitHub.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;dplyr&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:stats&amp;#39;:
## 
##     filter, lag&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &amp;#39;package:base&amp;#39;:
## 
##     intersect, setdiff, setequal, union&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;dplyr-verbs&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;dplyr Verbs&lt;/h4&gt;
&lt;p&gt;dplyr provides a set of verbs that help us solve the most common data manipulation challenges while working with tabular data (dataframes, tibbles):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt;: returns subset of columns&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter&lt;/code&gt;: returns a subset of rows&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arrange&lt;/code&gt;: re-order or arrange rows according to single/multiple variables&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mutate&lt;/code&gt;: create new columns from existing columns&lt;/li&gt;
&lt;li&gt;&lt;code&gt;summarise&lt;/code&gt;: reduce data to a single summary&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let us explore each of the above verbs one by one. &lt;code&gt;dplyr&lt;/code&gt; offers more functionality than the above listed verbs but we will explore them in a different post.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;case-study&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Case Study&lt;/h4&gt;
&lt;p&gt;We will explore dummy data that we have created to resemble web logs of a ecommerce company. You can download the data from &lt;a href=&#34;https://github.com/rsquaredacademy/datasets/blob/master/web.csv&#34;&gt;here&lt;/a&gt;. Below is the description of the data set:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Parsed with column specification:
## cols(
##   id = col_integer(),
##   referrer = col_character(),
##   device = col_character(),
##   bouncers = col_character(),
##   n_visit = col_integer(),
##   n_pages = col_double(),
##   duration = col_integer(),
##   country = col_character(),
##   purchase = col_character(),
##   order_items = col_double(),
##   order_value = col_double()
## )&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;id: row id&lt;/li&gt;
&lt;li&gt;referrer: referrer website/search engine&lt;/li&gt;
&lt;li&gt;os: operating system&lt;/li&gt;
&lt;li&gt;browser: browser&lt;/li&gt;
&lt;li&gt;device: device used to visit the website&lt;/li&gt;
&lt;li&gt;n_pages: number of pages visited&lt;/li&gt;
&lt;li&gt;duration: time spent on the website (in seconds)&lt;/li&gt;
&lt;li&gt;repeat: frequency of visits&lt;/li&gt;
&lt;li&gt;country: country of origin&lt;/li&gt;
&lt;li&gt;purchase: whether visitor purchased&lt;/li&gt;
&lt;li&gt;order_value: order value of visitor (in dollars)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will use dplyr to answer a few questions we have about the above data.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;average-order-value&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Average Order Value&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;What is the average order value by device types?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Average value of every order placed over a defined period of time. It is determined using sales per order and not sales per customer. Let us look at the steps to calculate AOV from the ecommerce data set.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: Filter Purchasers&lt;/li&gt;
&lt;li&gt;Step 2: Select data related to AOV (order value, order items) and device&lt;/li&gt;
&lt;li&gt;Step 3: Group order value and order items by device&lt;/li&gt;
&lt;li&gt;Step 4: Compute total order value and order items for each device&lt;/li&gt;
&lt;li&gt;Step 5: Compute AOV for each device&lt;/li&gt;
&lt;li&gt;Step 6: Select device and AOV data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Below is the code for computing AOV by device types:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom %&amp;gt;%
  filter(purchase == &amp;#39;true&amp;#39;) %&amp;gt;%
  select(device, order_value, order_items) %&amp;gt;%
  group_by(device) %&amp;gt;%
  summarise_all(funs(sum)) %&amp;gt;%
  mutate(
    aov = order_value / order_items
  ) %&amp;gt;%
  select(device, aov)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 × 2
##   device      aov
##    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
## 1 laptop 319.1292
## 2 mobile 253.9381
## 3 tablet 270.2320&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will map the dplyr verbs to the above steps.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;step-1-filter-purchasers&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Step 1: Filter Purchasers&lt;/h3&gt;
&lt;p&gt;In order to compute the AOV, we must first separate the purchasers from non-purchasers. We will do this by filtering the data related to purchasers using the &lt;code&gt;filter()&lt;/code&gt; function. It allows us to filter rows that meet a specific criteria/condition. The first argument is the name of the data frame and the rest of the arguments are expressions for filtering the data. Let us look at a few examples:&lt;/p&gt;
&lt;div id=&#34;filter&#34; class=&#34;section level5&#34;&gt;
&lt;h5&gt;Filter&lt;/h5&gt;
&lt;p&gt;Select all visits from mobile&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(ecom, device == &amp;quot;mobile&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 344 × 11
##       id referrer device bouncers n_visit n_pages duration        country
##    &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;          &amp;lt;chr&amp;gt;
## 1      5    yahoo mobile     true       9       1      899         Poland
## 2      7    yahoo mobile     true      10       1      692     Bangladesh
## 3      8   direct mobile     true      10       1      578      Indonesia
## 4      9     bing mobile    false       3      19      794    Netherlands
## 5     10   google mobile     true       6       1      762 Czech Republic
## 6     13   direct mobile    false       9      14      386        Ireland
## 7     15    yahoo mobile    false       7       1      447         France
## 8     22   google mobile     true       5       1      188         Brazil
## 9     23     bing mobile    false       0       7      608         Russia
## 10    29   google mobile     true      10       1      164         Russia
## # ... with 334 more rows, and 3 more variables: purchase &amp;lt;chr&amp;gt;,
## #   order_items &amp;lt;dbl&amp;gt;, order_value &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Select all visits from mobile that converted&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(ecom, device == &amp;quot;mobile&amp;quot;, purchase == &amp;quot;true&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 90 × 11
##       id referrer device bouncers n_visit n_pages duration        country
##    &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;          &amp;lt;chr&amp;gt;
## 1     13   direct mobile    false       9      14      386        Ireland
## 2     15    yahoo mobile    false       7       1      447         France
## 3     23     bing mobile    false       0       7      608         Russia
## 4     36     bing mobile    false       1       1      325        Ireland
## 5     41     bing mobile    false       4      20      148 Czech Republic
## 6     49   social mobile    false       1       2      397         France
## 7     89   direct mobile    false       4       8      598        Ecuador
## 8     92   google mobile    false       5       8      594      Indonesia
## 9     98     bing mobile    false       3      18      410       Portugal
## 10   102   google mobile    false       2       3      958        Bahamas
## # ... with 80 more rows, and 3 more variables: purchase &amp;lt;chr&amp;gt;,
## #   order_items &amp;lt;dbl&amp;gt;, order_value &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Select all visits from mobile that visited more than 5 pages&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(ecom, device == &amp;quot;mobile&amp;quot;, n_pages &amp;gt; 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 139 × 11
##       id referrer device bouncers n_visit n_pages duration        country
##    &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;          &amp;lt;chr&amp;gt;
## 1      9     bing mobile    false       3      19      794    Netherlands
## 2     13   direct mobile    false       9      14      386        Ireland
## 3     23     bing mobile    false       0       7      608         Russia
## 4     30    yahoo mobile    false       8       9      868       Colombia
## 5     41     bing mobile    false       4      20      148 Czech Republic
## 6     42   direct mobile    false       1      13      882      Indonesia
## 7     89   direct mobile    false       4       8      598        Ecuador
## 8     92   google mobile    false       5       8      594      Indonesia
## 9     98     bing mobile    false       3      18      410       Portugal
## 10   112   social mobile    false      10      11      350      Argentina
## # ... with 129 more rows, and 3 more variables: purchase &amp;lt;chr&amp;gt;,
## #   order_items &amp;lt;dbl&amp;gt;, order_value &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For our case study, we want all visits that converted.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(ecom, purchase == &amp;quot;true&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 254 × 11
##       id referrer device bouncers n_visit n_pages duration     country
##    &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;       &amp;lt;chr&amp;gt;
## 1      4     bing tablet    false       3      18      155       China
## 2     13   direct mobile    false       9      14      386     Ireland
## 3     14    yahoo tablet    false       5       8      260 Philippines
## 4     15    yahoo mobile    false       7       1      447      France
## 5     17     bing tablet    false       5      16       96        Peru
## 6     19   social tablet    false       7      10      346    Colombia
## 7     20   social tablet    false       2       1      412     Namibia
## 8     23     bing mobile    false       0       7      608      Russia
## 9     27   direct tablet    false       2      19      473       Japan
## 10    34   social tablet    false       9      20      385   Indonesia
## # ... with 244 more rows, and 3 more variables: purchase &amp;lt;chr&amp;gt;,
## #   order_items &amp;lt;dbl&amp;gt;, order_value &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;step-2-select-relevant-columns&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Step 2: Select relevant columns&lt;/h4&gt;
&lt;p&gt;After filtering the data, we need to select relevent variables to compute the AOV. Remember, we do not need all the columns in the data to compute a required metric (in our case, AOV). The &lt;code&gt;select()&lt;/code&gt; function allows us to select a subset of columns. The first argument is the name of the data frame and the subsequent arguments specify the columns by name or position. Let us look at a few examples:&lt;/p&gt;
&lt;p&gt;Select device and purchase columns&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(ecom, device, purchase)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,000 × 2
##    device purchase
##     &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;
## 1  laptop    false
## 2  tablet    false
## 3  laptop    false
## 4  tablet     true
## 5  mobile    false
## 6  laptop    false
## 7  mobile    false
## 8  mobile    false
## 9  mobile    false
## 10 mobile    false
## # ... with 990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Select all columns from device to purchase&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(ecom, device:purchase)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,000 × 7
##    device bouncers n_visit n_pages duration        country purchase
##     &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;          &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;
## 1  laptop     true      10       1       27 Czech Republic    false
## 2  tablet     true       9       1      899          Yemen    false
## 3  laptop     true       0       1       72         Brazil    false
## 4  tablet    false       3      18      155          China     true
## 5  mobile     true       9       1      899         Poland    false
## 6  laptop    false       5       5      573   South Africa    false
## 7  mobile     true      10       1      692     Bangladesh    false
## 8  mobile     true      10       1      578      Indonesia    false
## 9  mobile    false       3      19      794    Netherlands    false
## 10 mobile     true       6       1      762 Czech Republic    false
## # ... with 990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Select all columns excluding id and country&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(ecom, -id, -country)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,000 × 9
##    referrer device bouncers n_visit n_pages duration purchase order_items
##       &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
## 1    google laptop     true      10       1       27    false           0
## 2     yahoo tablet     true       9       1      899    false           0
## 3    direct laptop     true       0       1       72    false           0
## 4      bing tablet    false       3      18      155     true           6
## 5     yahoo mobile     true       9       1      899    false           0
## 6     yahoo laptop    false       5       5      573    false           0
## 7     yahoo mobile     true      10       1      692    false           0
## 8    direct mobile     true      10       1      578    false           0
## 9      bing mobile    false       3      19      794    false           0
## 10   google mobile     true       6       1      762    false           0
## # ... with 990 more rows, and 1 more variables: order_value &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For our case study, we need to select the columns order value and order items to calculate the AOV. We also need to select the device column as we are computing the AOV for different devices.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(ecom, device, order_value, order_items)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,000 × 3
##    device order_value order_items
##     &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1  laptop           0           0
## 2  tablet           0           0
## 3  laptop           0           0
## 4  tablet         434           6
## 5  mobile           0           0
## 6  laptop           0           0
## 7  mobile           0           0
## 8  mobile           0           0
## 9  mobile           0           0
## 10 mobile           0           0
## # ... with 990 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But we want the above data only for purchasers. We will combine &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;select()&lt;/code&gt; functions to extract data related to purchasers.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom1 &amp;lt;- filter(ecom, purchase == &amp;quot;true&amp;quot;)
ecom2 &amp;lt;- select(ecom1, device, order_value, order_items)
ecom2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 254 × 3
##    device order_value order_items
##     &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1  tablet         434           6
## 2  mobile         651           3
## 3  tablet         362           2
## 4  mobile        2423           7
## 5  tablet        1049           6
## 6  tablet        1304           9
## 7  tablet        2077           7
## 8  mobile         237           4
## 9  tablet         622           5
## 10 tablet        1613           7
## # ... with 244 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;step-3-group-data-by-devices&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Step 3: Group data by devices&lt;/h4&gt;
&lt;p&gt;Since we want to compute the AOV for each device, we need to compute the total order value and total order items for each device. To achieve this, we will group the selected variables by device type. Using the &lt;code&gt;group_by()&lt;/code&gt; function, we will group our case study data by device types. The first argument is the name of the data frame and the second argument is the name of the column based on which the data will be split. Let us look at a few examples:&lt;/p&gt;
&lt;p&gt;Group data by referrer type&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;group_by(ecom, referrer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [1,000 x 11]
## Groups: referrer [5]
## 
##       id referrer device bouncers n_visit n_pages duration        country
##    &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;          &amp;lt;chr&amp;gt;
## 1      1   google laptop     true      10       1       27 Czech Republic
## 2      2    yahoo tablet     true       9       1      899          Yemen
## 3      3   direct laptop     true       0       1       72         Brazil
## 4      4     bing tablet    false       3      18      155          China
## 5      5    yahoo mobile     true       9       1      899         Poland
## 6      6    yahoo laptop    false       5       5      573   South Africa
## 7      7    yahoo mobile     true      10       1      692     Bangladesh
## 8      8   direct mobile     true      10       1      578      Indonesia
## 9      9     bing mobile    false       3      19      794    Netherlands
## 10    10   google mobile     true       6       1      762 Czech Republic
## # ... with 990 more rows, and 3 more variables: purchase &amp;lt;chr&amp;gt;,
## #   order_items &amp;lt;dbl&amp;gt;, order_value &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the second line in the above output, you can observe &lt;code&gt;Groups: referrer [5]&lt;/code&gt;. The data is split into 5 groups as the referrer variable has 5 distinct values. For our case study, we need to group the data by device type.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom3 &amp;lt;- group_by(ecom2, device)
ecom3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [254 x 3]
## Groups: device [3]
## 
##    device order_value order_items
##     &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1  tablet         434           6
## 2  mobile         651           3
## 3  tablet         362           2
## 4  mobile        2423           7
## 5  tablet        1049           6
## 6  tablet        1304           9
## 7  tablet        2077           7
## 8  mobile         237           4
## 9  tablet         622           5
## 10 tablet        1613           7
## # ... with 244 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;step-4-compute-total-order-value-and-order-items&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Step 4: Compute total order value and order items&lt;/h4&gt;
&lt;p&gt;The next step is to compute the total order value and total order items for each device. We will use them to then compute the average order value. Now we need to reduce the order value and order items data to a single summary. We can achieve this using the &lt;code&gt;summarise()&lt;/code&gt; function. The first argument is the name of a data frame and the subsequent arguments are functions that can generate a summary. For example, we can use &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;mean&lt;/code&gt; etc.&lt;/p&gt;
&lt;p&gt;For our case study, we need the totals of order value and order items. What function can we use to obtain them? The &lt;code&gt;sum()&lt;/code&gt; function will generate the sum of the values and hence we will use it inside the &lt;code&gt;summarise()&lt;/code&gt; function. Remember, we need to provide a name to the summary being generated.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom4 &amp;lt;- summarise(ecom3, total_value = sum(order_value),
          total_items = sum(order_items))
ecom4&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 × 3
##   device total_value total_items
##    &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1 laptop      143289         449
## 2 mobile      127223         501
## 3 tablet      116470         431&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There you go, we have the total order value and total order items for each device type. Another way to achieve the above result is to use the &lt;code&gt;summarise_all()&lt;/code&gt; function. How does that work? It generates the specified summary for all the columns in the data set except for the column based on which the data has been grouped. So we need to ensure that the data frame does not have any irrelevant columns.&lt;/p&gt;
&lt;p&gt;In our case study, we have split the data based on the device type and we have 2 other columns which are order value and order items. If we use &lt;code&gt;summarise_all()&lt;/code&gt; function, it will generate the summary for the two columns based on the function specified. To specify the functions, we need to use another argument &lt;code&gt;funs&lt;/code&gt; and it can take any number of valid functions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom4 &amp;lt;- summarise_all(ecom3, funs(sum))
ecom4&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 × 3
##   device order_value order_items
##    &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
## 1 laptop      143289         449
## 2 mobile      127223         501
## 3 tablet      116470         431&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;step-5-compute-aov&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Step 5: Compute AOV&lt;/h4&gt;
&lt;p&gt;Now that we have the total order value and total order items for each device category, we can compute the AOV. We will create a new column to store the result. To create a new column, we will use the &lt;code&gt;mutate()&lt;/code&gt; function. The first argument is the name of the data frame and the subsequent arguments are expressions for creating new columns based out of existing columns.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom5 &amp;lt;- mutate(ecom4, aov = order_value / order_items)
ecom5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 × 4
##   device order_value order_items      aov
##    &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1 laptop      143289         449 319.1292
## 2 mobile      127223         501 253.9381
## 3 tablet      116470         431 270.2320&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;step-6-select-the-relevant-columns&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Step 6: Select the relevant columns&lt;/h4&gt;
&lt;p&gt;The last step is to select the relevant columns. We require the device type and the corresponding aov and hence we can get rid of other columns. Use the &lt;code&gt;select()&lt;/code&gt; function to extract the relevant columns.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom6 &amp;lt;- select(ecom5, device, aov)
ecom6&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 × 2
##   device      aov
##    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
## 1 laptop 319.1292
## 2 mobile 253.9381
## 3 tablet 270.2320&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let us combine all the code from the above steps:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom1 &amp;lt;- filter(ecom, purchase == &amp;quot;true&amp;quot;)
ecom2 &amp;lt;- select(ecom1, device, order_value, order_items)
ecom3 &amp;lt;- group_by(ecom2, device)
ecom4 &amp;lt;- summarise_all(ecom3, funs(sum))
ecom5 &amp;lt;- mutate(ecom4, aov = order_value / order_items)
ecom6 &amp;lt;- select(ecom5, device, aov)
ecom6&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 × 2
##   device      aov
##    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
## 1 laptop 319.1292
## 2 mobile 253.9381
## 3 tablet 270.2320&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you observe, at each step we create a new variable(data frame) and then use it as an input in the next step i.e. the output from one function becomes the input for another function. Can we achieve the final outcome i.e. &lt;code&gt;ecom6&lt;/code&gt; without creating the intermediate data frames (ecom1 - ecom5)? Yes, we can. We will use the &lt;code&gt;%&amp;gt;%&lt;/code&gt; operator to chain the above steps so that we can avoid creating the intermediate data frames. Let us see how to do that.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ecom %&amp;gt;%
  filter(purchase == &amp;#39;true&amp;#39;) %&amp;gt;%
  select(device, order_value, order_items) %&amp;gt;%
  group_by(device) %&amp;gt;%
  summarise_all(funs(sum)) %&amp;gt;%
  mutate(
    aov = order_value / order_items
  ) %&amp;gt;%
  select(device, aov)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 × 2
##   device      aov
##    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
## 1 laptop 319.1292
## 2 mobile 253.9381
## 3 tablet 270.2320&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above code, we take the output from each step and use it as an input for the next step using the pipe &lt;code&gt;%&amp;gt;%&lt;/code&gt; operator. It reduces the intermediate data frames and makes the code readable. Take the &lt;code&gt;ecom&lt;/code&gt; data frame &lt;code&gt;-&amp;gt;&lt;/code&gt; filter the purchasers &lt;code&gt;-&amp;gt;&lt;/code&gt; select device, order_value and order_items variables &lt;code&gt;-&amp;gt;&lt;/code&gt; group the resulting data frame by device type &lt;code&gt;-&amp;gt;&lt;/code&gt; compute the sum of all the variables in the grouped data frames &lt;code&gt;-&amp;gt;&lt;/code&gt; compute the average order value &lt;code&gt;-&amp;gt;&lt;/code&gt; select device type and aov&lt;/p&gt;
&lt;p&gt;It is the same as the steps we wrote at the beginning of this post. Now you realize how powerful dplyr is along with the &lt;code&gt;%&amp;gt;%&lt;/code&gt; operator. There are other functions in dplyr but we will cover them in another post. You are encouraged to use the above approach to answer the questions we have listed below.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;practice-questions&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Practice Questions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;What is the average number of pages visited by purchasers and non-purchasers?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;What is the average time on site for purchasers vs non-purchasers?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;What is the average number of pages visited by purchasers and non-purchasers using mobile?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;summary&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Summary&lt;/h4&gt;
&lt;p&gt;In this post, we learnt how to use dplyr to address some of the most common data manipulation challenges. In the next post, we will learn how to work with dates and time in R using the &lt;a href=&#34;https://CRAN.R-project.org/package=lubridate&#34;&gt;lubridate&lt;/a&gt; package.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Readable Code with Pipes</title>
      <link>/post/readable-code-with-pipes/</link>
      <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/readable-code-with-pipes/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
    <item>
      <title>Quick Guide: R &amp; SQLite</title>
      <link>/post/quick-guide-r-sqlite/</link>
      <pubDate>Sun, 05 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/quick-guide-r-sqlite/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
    <item>
      <title>RMySQL for Beginners</title>
      <link>/post/rmysql-for-beginners/</link>
      <pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/rmysql-for-beginners/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;div id=&#34;objectives&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Objectives&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Install and load RMySQL package&lt;/li&gt;
&lt;li&gt;Connect to a MySQL database from R&lt;/li&gt;
&lt;li&gt;Display database information&lt;/li&gt;
&lt;li&gt;List tables in the database&lt;/li&gt;
&lt;li&gt;Create new table&lt;/li&gt;
&lt;li&gt;Import data into R for analysis&lt;/li&gt;
&lt;li&gt;Export data from R into MySQL&lt;/li&gt;
&lt;li&gt;Remove tables and disconnect&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;In real world, data is often stored in relational databases such as MySQL and an analyst is required to extract the data in order to perform any type of analysis. If you are using R for statistical analysis and a relational database for storing the data, you need to interact with the database in order to access the data sets.&lt;/p&gt;
&lt;p&gt;One way to accomplish the above task is to export the data from the database in some file format and import the same into R. Similarly, if you have some data as a dataframe in R and want to store it in a database, you will need to export the data from R and import it into the database. This method can be very cumbersome and frustrating.&lt;/p&gt;
&lt;p&gt;The RMySQL package was created to help R users to easily access a MySQL database from R. In order to take advantage of the features available in the package, you need the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Access to a MySQL database&lt;/li&gt;
&lt;li&gt;Knowledge of basic SQL commmands&lt;/li&gt;
&lt;li&gt;Latest verison of R (verison 3.3.3)&lt;/li&gt;
&lt;li&gt;Latest version of RStudio (version 1.0.136)&lt;/li&gt;
&lt;li&gt;RMySQL package (version 0.10.11)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;installation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/RMySQL/index.html&#34;&gt;RMySQL&lt;/a&gt; package allows you to access MySQL database form R. It was created by &lt;a href=&#34;http://biostat.mc.vanderbilt.edu/wiki/Main/JeffreyHorner&#34;&gt;Jeffrey Horner&lt;/a&gt; but is currently maintained by &lt;a href=&#34;https://github.com/jeroen&#34;&gt;Jeroen Ooms&lt;/a&gt;. The latest version of the pacakge is 0.10.11. You can install and load the package using the following commands:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# install the package
install.packages(&amp;#39;RMySQL&amp;#39;)

# load the package
library(RMySQL)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;connect-to-database&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Connect to Database&lt;/h3&gt;
&lt;p&gt;We can establish a connection to a MySQL database using the &lt;code&gt;dbConnect()&lt;/code&gt; function. In order to connect to the database, we need to specify the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL connection&lt;/li&gt;
&lt;li&gt;database name&lt;/li&gt;
&lt;li&gt;username&lt;/li&gt;
&lt;li&gt;password&lt;/li&gt;
&lt;li&gt;host details&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Below is an example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;con &amp;lt;- dbConnect(MySQL(), user = &amp;#39;root&amp;#39;, password = &amp;#39;password&amp;#39;,
                 host = &amp;#39;localhost&amp;#39;, dbname = &amp;#39;dbname&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;connection-summary&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Connection Summary&lt;/h3&gt;
&lt;p&gt;We can get a summary or metadata of the connection using &lt;code&gt;summary()&lt;/code&gt; function. We need to specify the name of the MySQL connection object for which we are seeking metadata. Let us look at the metadata of the MySQL connection object we just created:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(con)
# &amp;lt;MySQLConnection:0,0&amp;gt;
#    User: root
#    Host: localhost
#    Dbname: world
#    Connection type: localhost via TCP/IP&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;database-info&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Database Info&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;dbGetInfo()&lt;/code&gt; function can be used to access information about the database to which we have established a connection. Among other things, it will return the following information about host, server and connection:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dbGetInfo(con)
# $host
# [1]&amp;quot;localhost&amp;quot;
# 
# $user
# [1]&amp;quot;root&amp;quot;
# 
# $dbname
# [1]&amp;quot;world&amp;quot;
# 
# $conType
# [1]&amp;quot;localhost via TCP/IP&amp;quot;
# 
# $serveVersion
# [1]&amp;quot;5.7.9-log&amp;quot;
# 
# $protocolVersion
# [1]10
# 
# $threadId
# [1]7
# 
# $rsld
# list()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;list-tables&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;List Tables&lt;/h3&gt;
&lt;p&gt;Once we have successfully established a connection to a MySQL database, we can use the &lt;code&gt;dbListTables()&lt;/code&gt; function to assess the list of tables that are present in that particular database. We need to specify the name of the MySQL connection object for which we are seeking the list of tables.&lt;/p&gt;
&lt;p&gt;Below is an example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# list of tables in the database
dbListTables(con)
# [1] &amp;quot;city&amp;quot;  &amp;quot;country&amp;quot; &amp;quot;countrylanguage&amp;quot; &amp;quot;mtcars&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, there are four tables in the database to which we established the connection through RMySQL package. In the &lt;code&gt;dbListTables()&lt;/code&gt; function, we have not specified the name of the database but the name of the MySQL connection object we created when we connected to the database.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;list-fields&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;List Fields&lt;/h3&gt;
&lt;p&gt;To get a list of fields or columns in a particular table in the database, we can use the &lt;code&gt;dbListFields()&lt;/code&gt; function. We need to specify the name of the MySQL connection object as well as the table name. If the table exists in the database, the names of the fields will be returned.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# list of fields in table city
dbListFields(con, &amp;quot;city&amp;quot;)
# [1] &amp;quot;ID&amp;quot;          &amp;quot;Name&amp;quot;          &amp;quot;CountryCode&amp;quot;  &amp;quot;District&amp;quot; 
# [5]&amp;quot;Population&amp;quot; &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The name of the table must be enclosed in single/double quotes and the name of the fields is returned as a character vector.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;testing-data-types&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Testing Data Types&lt;/h3&gt;
&lt;p&gt;To test the SQL data type of an object, we can use the &lt;code&gt;dbDataType()&lt;/code&gt; function. We need to specify the driver details as well as the object to test the SQL data type.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# data type
dbDataType(RMySQL::MySQL(), &amp;quot;a&amp;quot;)
# [1] &amp;quot;text&amp;quot;

dbDataType(RMySQL::MySQL(), 1:5)
# [1] &amp;quot;bigint&amp;quot;

dbDataType(RMySQL::MySQL(), 1.5)
# [1] &amp;quot;double&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;querying-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Querying Data&lt;/h3&gt;
&lt;p&gt;There are three different methods of querying data from a database:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;import the complete table using &lt;code&gt;dbReadTable()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;send query and retrieve results usinf &lt;code&gt;dbGetQuery()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;submit query using &lt;code&gt;dbSendQuery()&lt;/code&gt; and fetch results using &lt;code&gt;dbFetch()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let us explore each of the above methods one by one.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;import-table&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Import Table&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;dbReadTable()&lt;/code&gt; can be used to extract an entire table from a MySQL database. We can use this method only if the table is not very big. We need to specify the name of the MySQL connection object and the table. The name of the table must be enclosed in single/double quotes.&lt;/p&gt;
&lt;p&gt;In the below example, we read the entire table named &lt;strong&gt;trial&lt;/strong&gt; from the database:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dbReadTable(con, &amp;quot;trial&amp;quot;)
#     x y
# 1   1 a 
# 2   2 b
# 3   3 c
# 4   4 d
# 5   5 e
# 6   6 f
# 7   7 g
# 8   8 h
# 9   9 i
# 10 10 j&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A complete guide to importing data into R</title>
      <link>/post/a-complete-guide-to-importing-data-into-r/</link>
      <pubDate>Sun, 08 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/a-complete-guide-to-importing-data-into-r/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
    <item>
      <title>Descriptive Statistics.. What?</title>
      <link>/post/descriptive-statistics-what/</link>
      <pubDate>Fri, 06 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/descriptive-statistics-what/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
    <item>
      <title>RStudio 2 GitHub: GitHub Pages</title>
      <link>/post/github-pages/</link>
      <pubDate>Mon, 19 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/github-pages/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
    <item>
      <title>Git Command Line</title>
      <link>/post/git-command-line/</link>
      <pubDate>Wed, 07 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/git-command-line/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
    <item>
      <title>RStudio 2 GitHub: Git Branch Workflow</title>
      <link>/post/git-branch-workflow/</link>
      <pubDate>Thu, 24 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/git-branch-workflow/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

</description>
    </item>
    
  </channel>
</rss>